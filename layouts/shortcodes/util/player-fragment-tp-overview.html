{{ $id := "player-fragment-tp-overview" -}}
<div id="{{$id}}"></div>
<script>
    addEventListener("load", async () => { 
        let div = document.getElementById("{{$id}}");

        let player = gw2.apiHolder.getApiHolder().players
                .find((player)=>window.location.hash.slice(1) == player.name);
        if(!player) {
            div.replaceChildren(document.createTextNode("Please pick player"));
            return;
        }
        let api = gw2.apiHolder.getApiHolder().api;

        let divSpinner = div.appendChild(gw2.util.createSpinner());
        let divTxt = div.appendChild(document.createElement("span"));
        div.appendChild(document.createElement("h3")).innerText = "Summary";
        let divSummary = div.appendChild(document.createElement("div"));
        div.appendChild(document.createElement("h3")).innerText = "Delivery Box";
        let divDeliveryCoins = div.appendChild(document.createElement("div"));
        let divDeliveryTable = div.appendChild(document.createElement("div"));
        div.appendChild(document.createElement("h3")).innerText = "Transaction History - Buys (first 5 pages only)";
        let divTxHistoryBuysTable = div.appendChild(document.createElement("div"));
        // Do the work

        let formatterCoin = (cell, formatterParams, onRendered) => {
            let v = cell.getValue();
            if(v) {
                return gw2.util.int2coins(v).txt
            } else return "-";
        }
        // coin column
        let c = (col) => {
            col.headerHozAlign = "right";
            col.hozAlign = "right";
            col.formatter = formatterCoin;
            if(col.bottomCalc) col.bottomCalcFormatter = formatterCoin;
            return col;
        }

        let tableSummary = gw2.tables.createTableFromData(
            divSummary,
            [
                { title: "Include in sum",    field: "incl", hozAlign:"center", mutateLink: "c",  },
                { title: "",    field: "id" },
                c({ title: "Sum",  field: "c", bottomCalc: (values, data, calcParams)=> {
                    let calc = 0;
                    data.forEach((d)=>{ if(d.incl) { calc += d.c; } });
                    return calc;
                } }),
                
            ],
            [
                // WARNING! IDs are used as ids! See code below.
                { c: 0, incl: true,   id: "Wallet coins" },
                { c: 0, incl: true,   id: "Delivery Box coins" },
                { c: 0, incl: true,   id: "Delivery Box (sell, after tax)" },
                { c: 0, incl: true,   id: "Buy listings (listing)" },
                { c: 0, incl: true,   id: "Sell listings (listing, after tax)" },
                { c: 0, incl: false,  id: "Sell listings (buy)" },
                { c: 0, incl: false,  id: "Sell listings (sell)" },
            ]
        );
        await new Promise(resolve => tableSummary.on("tableBuilt", response => resolve(response)));

        divDeliveryCoins.appendChild(document.createTextNode("Delivery coins: "));
        
        // Delivery: Coins
        divTxt.innerText="Downloading delivery box contents";
        let delivery = await player.api.account().delivery().get();
        console.log(delivery);
        divDeliveryCoins.appendChild(document.createTextNode(gw2.util.int2coins(delivery.coins).txt));
        await tableSummary.updateData([{id:"Delivery Box coins", c: delivery.coins}]);
        await tableSummary.redraw();
        await tableSummary.recalc();
        
        divTxt.innerText="Creating delivery box table";

        let table1 = gw2.tables.createTableFromData(
            divDeliveryTable,
            [
                { title: "ID",      field: "id" },
                { title: "Cnt",     field: "count", headerHozAlign: "right", hozAlign:"right", mutateLink: ["buySum","sellSum"] },
                { title: "",        field: "icon", formatter:"image", formatterParams:{ height:"50px", width:"50px" } },
                { title: "Item",    field: "name" },
                c({ title: "Buy รก",   field: "buys.unit_price", mutateLink: "buySum",  }),
                c({ title: "Buy Sum", field: "buySum", bottomCalc:"sum",  mutator:(value, data)=>{
                    return (data?.count ?? 0) * (data?.buys?.unit_price ?? 0);
                }}),
                c({ title: "Sell รก",   field: "sells.unit_price", mutateLink: "sellSum",  }),
                c({ 
                    title: "Sell Sum",
                    field: "sellSum",
                    bottomCalc: (values, data, calcParams)=> {
                        let calc = 0;
                        data.forEach((d)=>{ calc += d.sellSum ?? 0; });
                        // This arrow-func can't be async. Let's just call these async functions and hope for the best...
                        tableSummary.updateData([{id:"Delivery Box (sell, after tax)", c: Math.floor(calc*0.85)}]);
                        tableSummary.redraw();
                        tableSummary.recalc();
                        return calc;
                    },
                    mutator:(value, data)=>{
                       return (data?.count ?? 0) * (data?.sells?.unit_price ?? 0);
                    }
                })
            ],
            delivery.items.map((i)=>{
                i.icon = "data:,"; // Stop the browser from doing "https://..../undefined" GETs. Maybe Tabular could be configured to stop 'em?..
                return i;
            })
        );
        await new Promise(resolve => table1.on("tableBuilt", response => resolve(response)));

        divTxt.innerText="Downloading delivery box items";
        let itemIds = delivery.items.map((item)=>item.id);
        if(itemIds.length > 0 ) {
            let items = await api.items().many(itemIds);
            await table1.updateData(items);
            await table1.redraw();
            await table1.recalc();

            divTxt.innerText="Downloading delivery box items' prices";
            let itemPrices = await api.commerce().prices().many(itemIds);
            console.log(itemPrices);
            await table1.updateData(itemPrices);
            await table1.redraw();
            await table1.recalc();
            
        }

        divTxt.innerText="Downloading wallet";
        let walletCoins = (await player.api.account().wallet().get()).find((w)=>w.id == 1).value;
        console.log("wallet", walletCoins);
        await tableSummary.updateData([{id:"Wallet coins", c: walletCoins}]);
        await tableSummary.redraw();
        await tableSummary.recalc();

        divTxt.innerText="Create table for transaction history (buys)";
        /*
            Since we are not interested in the a perfect history of the transactions, but instead
            in just the price we bought the item at,
            we fabricate the table id as follows: `${item_id}/${price}`.
            This combines "same item bought at the same price".
            We can omit the purchased and quantity fields, we're not interested in them.
            If we need more detailed analysis, we go to GW2Efficiency!
         */
        let table2 = gw2.tables.createTableFromData(
            divTxHistoryBuysTable,
            [
                { title: "ID",        field: "id" },
                { title: "",        field: "icon", formatter:"image", formatterParams:{ height:"50px", width:"50px" } },
                { title: "Item",    field: "name" },
                c({ title: "Price รก",   field: "price", mutateLink: "sell_for_zero_profit",  }),
                c({ title: "Sell for 0 profit", field: "sell_for_zero_profit", mutator:(value, data)=>{
                    return Math.ceil(data.price/0.85);
                }})
            ],
            [],
        );
        await new Promise(resolve => table2.on("tableBuilt", response => resolve(response)));

        for (let page = 0; page < 5; page++) {
            divTxt.innerText=`Downloading transaction history (buys) - page ${page}`;
            let txs = await player.api.commerce().transactions().history().buys().page(page, 50);
            let txsItems = (await api.items().many(txs.map((tx)=>tx.item_id)))
                    .reduce(function(map, obj) {
                        map[obj.id] = obj;
                        return map;
                    }, {});
            

            await table2.updateOrAddData(txs.map((tx)=>{
                return {
                    id: `${tx.item_id}/${tx.price}`,
                    name: txsItems[tx.item_id].name,
                    icon: txsItems[tx.item_id].icon,
                    price: tx.price,
                };
            }));
            await table2.redraw();
            await table2.recalc();
        }
        // divTxt.innerText="Downloading transaction history (buys) - items";
        // let txsItemIds = txs.map((tx)=>tx.item_id);
        // let txsItems = await api.items().many(itemIds);
        // await table2.updateData(items);

        let coinsBuyListings = 0;
        let coinsSellListings =0;
        let coinsSellListingsBuy = 0;
        let coinsSellListingsSell = 0;
        
        divTxt.innerText=`Downloading current buys`;
        let txsBuys = await player.api.commerce().transactions().current().buys().all();
        txsBuys.forEach((tx)=>{ coinsBuyListings += tx.quantity * tx.price; });
        await tableSummary.updateData([{id:"Buy listings (listing)", c: coinsBuyListings}]);
        await tableSummary.redraw();
        await tableSummary.recalc();

        divTxt.innerText=`Downloading current sells`;
        let txsSells = await player.api.commerce().transactions().current().sells().all();
        txsSells.forEach((tx)=>{ coinsSellListings += tx.quantity * tx.price; })
        await tableSummary.updateData([{id:"Sell listings (listing, after tax)", c: Math.floor(coinsSellListings*0.9)}]); // 0.9 = the 5% listing fee has already been paid when listing the items. The 10% is shaved when the transaction completes.
        await tableSummary.redraw();
        await tableSummary.recalc();

        divTxt.innerText=`Downloading current sells - current price data`;        
        

        divSpinner.remove();
        divTxt.remove();
    });
</script>
